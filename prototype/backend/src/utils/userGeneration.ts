import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Default robot attributes (all set to 1.00)
const DEFAULT_ROBOT_ATTRIBUTES = {
  combatPower: 1.0,
  targetingSystems: 1.0,
  criticalSystems: 1.0,
  penetration: 1.0,
  weaponControl: 1.0,
  attackSpeed: 1.0,
  armorPlating: 1.0,
  shieldCapacity: 1.0,
  evasionThrusters: 1.0,
  damageDampeners: 1.0,
  counterProtocols: 1.0,
  hullIntegrity: 1.0,
  servoMotors: 1.0,
  gyroStabilizers: 1.0,
  hydraulicSystems: 1.0,
  powerCore: 1.0,
  combatAlgorithms: 1.0,
  threatAnalysis: 1.0,
  adaptiveAI: 1.0,
  logicCores: 1.0,
  syncProtocols: 1.0,
  supportSystems: 1.0,
  formationTactics: 1.0,
};

// Robot name generator (reused from seed.ts)
const prefixes = [
  'Iron', 'Steel', 'Titanium', 'Cyber', 'Plasma', 'Quantum',
  'Thunder', 'Lightning', 'Frost', 'Inferno', 'Shadow', 'Light',
  'Battle', 'War', 'Combat', 'Strike', 'Guard', 'Shield',
  'Alpha', 'Beta', 'Gamma', 'Delta', 'Omega', 'Prime',
  'Crimson', 'Azure', 'Emerald', 'Golden', 'Silver', 'Bronze',
  'Viper', 'Falcon', 'Dragon', 'Phoenix', 'Griffin', 'Hydra',
  'Storm', 'Blaze', 'Crystal', 'Volt', 'Nova', 'Eclipse'
];

const suffixes = [
  'Gladiator', 'Warrior', 'Champion', 'Sentinel', 'Guardian',
  'Striker', 'Destroyer', 'Crusher', 'Breaker', 'Reaper',
  'Titan', 'Colossus', 'Behemoth', 'Juggernaut', 'Warlord',
  'Knight', 'Paladin', 'Vanguard', 'Enforcer', 'Protector',
  'Avenger', 'Hunter', 'Predator', 'Slayer', 'Annihilator',
  'Dominator', 'Conqueror', 'Victor', 'Defender', 'Vindicator',
  'Phantom', 'Specter', 'Wraith', 'Ghost', 'Shadow'
];

function generateRobotName(index: number): string {
  const prefix = prefixes[index % prefixes.length];
  const suffix = suffixes[Math.floor(index / prefixes.length) % suffixes.length];
  const variant = Math.floor(index / (prefixes.length * suffixes.length));
  
  if (variant > 0) {
    return `${prefix} ${suffix} ${variant + 1}`;
  }
  return `${prefix} ${suffix}`;
}

/**
 * Generate battle-ready users with fully equipped robots.
 * Each user receives:
 * - Unique username (auto_user_NNNN format)
 * - Starting currency: ₡100,000
 * - 1 robot with Practice Sword equipped
 * - Robot attributes: all set to 1.00 (baseline)
 * - Battle readiness: 100% (full HP, weapon equipped)
 * 
 * @param count - Number of users to generate
 * @returns Summary of users and robots created
 */
export async function generateBattleReadyUsers(count: number): Promise<{
  usersCreated: number;
  robotsCreated: number;
  usernames: string[];
}> {
  const startTime = Date.now();
  console.log(`[UserGeneration] Generating ${count} battle-ready users...`);

  // Get Practice Sword weapon for equipment
  const practiceSword = await prisma.weapon.findFirst({
    where: { name: 'Practice Sword' },
  });

  if (!practiceSword) {
    throw new Error('Practice Sword weapon not found. Database may not be seeded properly.');
  }

  const usernames: string[] = [];

  // Generate each user with robot
  for (let i = 0; i < count; i++) {
    try {
      // Generate unique username
      const existingCount = await prisma.user.count({
        where: { username: { startsWith: 'auto_user_' } },
      });
      const userNumber = existingCount + 1;
      const username = `auto_user_${String(userNumber).padStart(4, '0')}`;

      // Use transaction to ensure atomicity
      await prisma.$transaction(async (tx) => {
        // Create user
        // Note: Auto-generated users use a fixed dummy password hash. These accounts are
        // for simulation/testing purposes only and should not be used in production without
        // implementing proper authentication or marking them as system-generated.
        const user = await tx.user.create({
          data: {
            username,
            passwordHash: '$2b$10$dummyhashforautogeneratedusers123456789012345', // Dummy hash for auto-users
            currency: 100000, // ₡100,000 starting balance
            role: 'user',
          },
        });

        // Create weapon inventory entry for Practice Sword
        const weaponInventory = await tx.weaponInventory.create({
          data: {
            userId: user.id,
            weaponId: practiceSword.id,
          },
        });

        // Generate robot name based on total robot count
        const robotCount = await tx.robot.count();
        const robotName = generateRobotName(robotCount);

        // Create robot with Practice Sword equipped
        await tx.robot.create({
          data: {
            userId: user.id,
            name: robotName,
            frameId: 1,
            
            // All 23 attributes set to 1.00 via shared defaults
            ...DEFAULT_ROBOT_ATTRIBUTES,
            
            // Combat state (HP formula: 50 + (hullIntegrity × 5) = 50 + (1.00 × 5) = 55)
            currentHP: 55,
            maxHP: 55,
            currentShield: 2, // shieldCapacity × 2 = 1.00 × 2 = 2
            maxShield: 2,
            
            // Performance tracking
            elo: 1200, // Starting ELO
            
            // League
            currentLeague: 'bronze',
            leagueId: 'bronze_1',
            leaguePoints: 0,
            
            // Loadout
            loadoutType: 'single',
            mainWeaponId: weaponInventory.id,
            
            // Stance
            stance: 'balanced',
            
            // Battle readiness
            battleReadiness: 100,
            yieldThreshold: 10,
          },
        });
      });

      usernames.push(username);

      // Log progress every 10 users
      if ((i + 1) % 10 === 0 || i + 1 === count) {
        console.log(`[UserGeneration] Created ${i + 1}/${count} users...`);
      }
    } catch (error) {
      console.error(`[UserGeneration] Error creating user ${i + 1}:`, error);
      throw error; // Fail fast if any user creation fails
    }
  }

  const duration = Date.now() - startTime;
  console.log(`[UserGeneration] ✅ Created ${count} users with robots in ${duration}ms`);

  return {
    usersCreated: count,
    robotsCreated: count,
    usernames,
  };
}
